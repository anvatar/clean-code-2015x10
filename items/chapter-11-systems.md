<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [11장. 시스템](#11%EC%9E%A5-%EC%8B%9C%EC%8A%A4%ED%85%9C)
  - [시스템 생성(construction)과 시스템 사용(use)을 분리하라](#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%83%9D%EC%84%B1construction%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%82%AC%EC%9A%A9use%EC%9D%84-%EB%B6%84%EB%A6%AC%ED%95%98%EB%9D%BC)
  - [확장](#%ED%99%95%EC%9E%A5)
  - [관점 지향 프로그래밍](#%EA%B4%80%EC%A0%90-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
    - [자바 프록시](#%EC%9E%90%EB%B0%94-%ED%94%84%EB%A1%9D%EC%8B%9C)
    - [순수 자바 AOP 프레임워크](#%EC%88%9C%EC%88%98-%EC%9E%90%EB%B0%94-aop-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC)
    - [AspectJ 관점](#aspectj-%EA%B4%80%EC%A0%90)
  - [테스트 주도 시스템 아키텍처 구축](#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%B6%95)
  - [시스템은 도메인 특화 언어가 필요하다](#%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%ED%8A%B9%ED%99%94-%EC%96%B8%EC%96%B4%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 11장. 시스템

시스템이라는 높은 추상화 수준에서도 깨끗함을 유지하는 방법

## 시스템 생성(construction)과 시스템 사용(use)을 분리하라

관심사 분리는 우리 분야에서 가장 오래되고 가장 중요한 설계 기법 중 하나.

다음 두 관심사(concern)를 분리해야 체계적이고 탄탄한 시스템을 만들 수 있다:

- (애플리케이션 객체를 생성하고 의존성을 서로 '연결'하는) 시작 단계(startup process)
- (시작 단계 이후에 이어지는) 런타임 로직

두 관심사 분리에 실패한 전형적인 예: 초기화 지연 기법을 적용한 `getService()`

- 추상화가 아닌 구현체에 대한 의존성 (DIP 위반)
- 객체 생성과 객체 조회라는 두 가지 책임 (SRP 위반)
- 테스트 하기 불편함
- 이런 '좀스러운' 설정 기법이 애플리케이션 곳곳에 반복적으로 나타남 (모듈성 떨어짐)

시작 단계에서 주요 의존성을 해소하기 위한 방식 (간단한 것부터)

1. Main 분리
    - 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈에서 처리
    - 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정 (애플리케이션은 객체 생성 과정을 전혀 모름)
1. Abstract factory 패턴
    - 객체를 생성하는 시점은 애플리케이션이 결정
    - 객체를 생성하는 코드는 애플리케이션이 모름
1. 의존성 주입(dependency injection, DI)
    - 애플리케이션 객체는 객체 생성 책임을 맡지 않음 (SRP 지원)
    - '전담' 메커니즘(main 루틴이나 DI 컨테이너)이 객체를 생성하고 애플리케이션에 의존성을 주입 (제어 역전(inversion of control, IoC))
    - DI 컨테이너가 실제 생성하는 객체 유형은 설정 파일이나 특수 생성 모듈에 명시
    - DI 컨테이너도 내부적으로 계산 지연과 같은 최적화 기법을 사용하고 있음

## 확장

소프트웨어 아키텍처는 물리적인 시스템과 달리, 관심사를 적절히 분리해 관리한다면 점진적으로 발전할 수 있다.

관심사를 적절히 분리하지 못한 아키텍처의 예: EJB2

- 근본적인 문제: 비즈니스 로직이 EJB 컨테이너에 강하게 결합된다.
- 독자적인 단위 테스트가 어렵다.
- 비즈니스 로직을 프레임워크 밖에서 재사용할 수 없다.
- 동일한 정보를 저장하는 별도의 DTO(data transfer object) 필요
- 너무 많은 기술을 집어넣느라 관심사를 제대로 분리하지 못함.

횡단(cross-cutting) 관심사

- 영속성, 트랜잭션, 보안, ... : 애플리케이션 객체 경계를 넘나드는 경향이 있음
- 도메인 로직과 세밀한 단위로 겹치다보니 구현 코드가 온갖 객체로 흩어져 반복됨

## 관점 지향 프로그래밍

AOP(aspect-oriented programming)

- 관점: 특정 관심사를 지원하기 위해 일관된 방식으로 동작을 변경해야 하는 (시스템 상의) 지점
- 프로그래머가 간결한 선언이나 프로그래밍 메커니즘으로 관점을 명시해두면 AOP 프레임워크가 소스 코드에 영향을 미치지 않고 명시한 지점의 동작 방식을 변경한다.

자바에서 사용하는 메커니즘

- 자바 프록시
- 순수 자바 AOP 프레임워크
- AspectJ

### 자바 프록시

개별 객체나 메서드 호출을 감싸는 경우와 같은 단순한 상황에 적합.

- 인터페이스에 대한 프록시: JDK가 지원(동적 프록시 기능)
- 클래스에 대한 프록시: 바이트코드 처리 라이브러리(CGLIB, ASM, Javassist 등) 필요

Bank 인터페이스 예

- JDK 동적 프록시
- 코드가 상당히 많으며 제법 복잡함.
- 관점을 간결한 방식으로 명시하는 메커니즘 없음.
- 순수 자바 AOP 프레임워크의 동작 방식을 이해하는데 도움

### 순수 자바 AOP 프레임워크

프록시 방식을 자동화한 프레임워크

- 스프링 AOP, JBoss AOP, ...
- 비즈니스 로직을 프레임워크에 의존하지 않는 POJO로 구현
    - 테스트 하기 쉽다.
    - 올바르게 구현하기 쉽다.
    - 유지보수하기 쉽다.
- 애플리케이션 기반 구조는 설정 파일이나 어노테이션으로 구성
    - 영속성, 트랜잭션, 보안, 캐시, 장애조치 등의 횡단 관심사 포함
    - 프레임워크 내 DI 컨테이너가 의존성 주입
    - 사용자는 POJO로 구현한 객체를 사용한다고 착각
    - 실제로는 프록시나 바이트코드 라이브러리로 관점의 동작이 확장된, 중첩된 DECORATOR 구조의 가장 바깥쪽 객체가 사용됨.

### AspectJ 관점

관심사를 관점으로 분리하는 가장 강력한 도구

- 강력하고 풍부한 도구 집합
- 새 도구와 언어의 사용법을 익혀야 함

## 테스트 주도 시스템 아키텍처 구축

테스트 주도 방식으로 시스템 아키텍처를 진화시키기

- 도메인 로직을 POJO로 작성하여 코드 수준에서 아키텍처 관심사를 분리
- 관점이나 그와 유사한 도구를 사용해 도메인 로직을 통합
- 변화하는 환경에 대처해 진로를 변경할 수 있음.

관심사를 모듈로 분리한 POJO 시스템은 기민하다.

- 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기 쉽다.

명백한 가치가 있을 때만 표준을 현명하게 사용하라.

- 때로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못하거나,
- 원래 표준을 제정한 목적을 잊어버리는 경우도 있다.

## 시스템은 도메인 특화 언어가 필요하다

도메인 특화 언어(domain-specific language, DSL)

- 도메인 개념과 그 개념을 구현한 코드 사이의 '의사소통의 간극'을 줄여준다.
- 잘 사용하면 코드가 전문가가 작성한 산문처럼 읽힌다.
- 도메인을 잘못 구현할 가능성이 줄어든다.
- 추상화의 수준을 최대한으로 끌어 올릴 수 있다.
