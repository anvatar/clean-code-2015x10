<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [17장. 냄새와 휴리스틱](#17%EC%9E%A5-%EB%83%84%EC%83%88%EC%99%80-%ED%9C%B4%EB%A6%AC%EC%8A%A4%ED%8B%B1)
  - [주석](#%EC%A3%BC%EC%84%9D)
    - [C1: 부적절한 정보](#c1-%EB%B6%80%EC%A0%81%EC%A0%88%ED%95%9C-%EC%A0%95%EB%B3%B4)
    - [C2: 쓸모없는 주석](#c2-%EC%93%B8%EB%AA%A8%EC%97%86%EB%8A%94-%EC%A3%BC%EC%84%9D)
    - [C3: 중복된 주석](#c3-%EC%A4%91%EB%B3%B5%EB%90%9C-%EC%A3%BC%EC%84%9D)
    - [C4: 성의 없는 주석](#c4-%EC%84%B1%EC%9D%98-%EC%97%86%EB%8A%94-%EC%A3%BC%EC%84%9D)
    - [C5: 주석 처리된 코드](#c5-%EC%A3%BC%EC%84%9D-%EC%B2%98%EB%A6%AC%EB%90%9C-%EC%BD%94%EB%93%9C)
  - [환경](#%ED%99%98%EA%B2%BD)
    - [E1: 여러 단계로 빌드해야 한다](#e1-%EC%97%AC%EB%9F%AC-%EB%8B%A8%EA%B3%84%EB%A1%9C-%EB%B9%8C%EB%93%9C%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4)
    - [E2: 여러 단계로 테스트해야 한다](#e2-%EC%97%AC%EB%9F%AC-%EB%8B%A8%EA%B3%84%EB%A1%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4)
  - [함수](#%ED%95%A8%EC%88%98)
    - [F1: 너무 많은 인수](#f1-%EB%84%88%EB%AC%B4-%EB%A7%8E%EC%9D%80-%EC%9D%B8%EC%88%98)
    - [F2: 출력 인수](#f2-%EC%B6%9C%EB%A0%A5-%EC%9D%B8%EC%88%98)
    - [F3: 플래그 인수](#f3-%ED%94%8C%EB%9E%98%EA%B7%B8-%EC%9D%B8%EC%88%98)
    - [F4: 죽은 함수](#f4-%EC%A3%BD%EC%9D%80-%ED%95%A8%EC%88%98)
  - [일반](#%EC%9D%BC%EB%B0%98)
    - [G1: 한 소스 파일에 여러 언어를 사용한다](#g1-%ED%95%9C-%EC%86%8C%EC%8A%A4-%ED%8C%8C%EC%9D%BC%EC%97%90-%EC%97%AC%EB%9F%AC-%EC%96%B8%EC%96%B4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4)
    - [G2: 당연한 동작을 구현하지 않는다](#g2-%EB%8B%B9%EC%97%B0%ED%95%9C-%EB%8F%99%EC%9E%91%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4)
    - [G3: 경계를 올바로 처리하지 않는다](#g3-%EA%B2%BD%EA%B3%84%EB%A5%BC-%EC%98%AC%EB%B0%94%EB%A1%9C-%EC%B2%98%EB%A6%AC%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4)
    - [G4: 안전 절차 무시](#g4-%EC%95%88%EC%A0%84-%EC%A0%88%EC%B0%A8-%EB%AC%B4%EC%8B%9C)
    - [G5: 중복](#g5-%EC%A4%91%EB%B3%B5)
    - [G6: 추상화 수준이 올바르지 못하다](#g6-%EC%B6%94%EC%83%81%ED%99%94-%EC%88%98%EC%A4%80%EC%9D%B4-%EC%98%AC%EB%B0%94%EB%A5%B4%EC%A7%80-%EB%AA%BB%ED%95%98%EB%8B%A4)
    - [G7: 기초 클래스가 파생 클래스에 의존한다](#g7-%EA%B8%B0%EC%B4%88-%ED%81%B4%EB%9E%98%EC%8A%A4%EA%B0%80-%ED%8C%8C%EC%83%9D-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EC%9D%98%EC%A1%B4%ED%95%9C%EB%8B%A4)
    - [G8: 과도한 정보](#g8-%EA%B3%BC%EB%8F%84%ED%95%9C-%EC%A0%95%EB%B3%B4)
    - [G9: 죽은 코드](#g9-%EC%A3%BD%EC%9D%80-%EC%BD%94%EB%93%9C)
    - [G10: 수직 분리](#g10-%EC%88%98%EC%A7%81-%EB%B6%84%EB%A6%AC)
    - [G11: 일관성 부족](#g11-%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%B6%80%EC%A1%B1)
    - [G12: 잡동사니](#g12-%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88)
    - [G13: 인위적 결합](#g13-%EC%9D%B8%EC%9C%84%EC%A0%81-%EA%B2%B0%ED%95%A9)
    - [G14: 기능 욕심](#g14-%EA%B8%B0%EB%8A%A5-%EC%9A%95%EC%8B%AC)
    - [G15: 선택자 인수](#g15-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%9D%B8%EC%88%98)
    - [G16: 모호한 의도](#g16-%EB%AA%A8%ED%98%B8%ED%95%9C-%EC%9D%98%EB%8F%84)
    - [G17: 잘못 지운 책임](#g17-%EC%9E%98%EB%AA%BB-%EC%A7%80%EC%9A%B4-%EC%B1%85%EC%9E%84)
    - [G18: 부적절한 static 함수](#g18-%EB%B6%80%EC%A0%81%EC%A0%88%ED%95%9C-static-%ED%95%A8%EC%88%98)
    - [G19: 서술적 변수](#g19-%EC%84%9C%EC%88%A0%EC%A0%81-%EB%B3%80%EC%88%98)
    - [G20: 이름과 기능이 일치하는 함수](#g20-%EC%9D%B4%EB%A6%84%EA%B3%BC-%EA%B8%B0%EB%8A%A5%EC%9D%B4-%EC%9D%BC%EC%B9%98%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98)
    - [G21: 알고리즘을 이해하라](#g21-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EB%9D%BC)
    - [G22: 논리적 의존성은 물리적으로 드러내라](#g22-%EB%85%BC%EB%A6%AC%EC%A0%81-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%80-%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%93%9C%EB%9F%AC%EB%82%B4%EB%9D%BC)
    - [G23: if/else 혹은 switch/case 문보다 다형성을 사용하라](#g23-ifelse-%ED%98%B9%EC%9D%80-switchcase-%EB%AC%B8%EB%B3%B4%EB%8B%A4-%EB%8B%A4%ED%98%95%EC%84%B1%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
    - [G24: 표준 표기법을 따르라](#g24-%ED%91%9C%EC%A4%80-%ED%91%9C%EA%B8%B0%EB%B2%95%EC%9D%84-%EB%94%B0%EB%A5%B4%EB%9D%BC)
    - [G25: 매직 숫자는 명명된 상수로 교체하라](#g25-%EB%A7%A4%EC%A7%81-%EC%88%AB%EC%9E%90%EB%8A%94-%EB%AA%85%EB%AA%85%EB%90%9C-%EC%83%81%EC%88%98%EB%A1%9C-%EA%B5%90%EC%B2%B4%ED%95%98%EB%9D%BC)
    - [G26: 정확하라](#g26-%EC%A0%95%ED%99%95%ED%95%98%EB%9D%BC)
    - [G27: 관례보다 구조를 사용하라](#g27-%EA%B4%80%EB%A1%80%EB%B3%B4%EB%8B%A4-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
    - [G28: 조건을 캡슐화하라](#g28-%EC%A1%B0%EA%B1%B4%EC%9D%84-%EC%BA%A1%EC%8A%90%ED%99%94%ED%95%98%EB%9D%BC)
    - [G29: 부정 조건은 피하라](#g29-%EB%B6%80%EC%A0%95-%EC%A1%B0%EA%B1%B4%EC%9D%80-%ED%94%BC%ED%95%98%EB%9D%BC)
    - [G30: 함수는 한 가지만 해야 한다](#g30-%ED%95%A8%EC%88%98%EB%8A%94-%ED%95%9C-%EA%B0%80%EC%A7%80%EB%A7%8C-%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4)
    - [G31: 숨겨진 시간적 결합](#g31-%EC%88%A8%EA%B2%A8%EC%A7%84-%EC%8B%9C%EA%B0%84%EC%A0%81-%EA%B2%B0%ED%95%A9)
    - [G32: 일관성을 유지하라](#g32-%EC%9D%BC%EA%B4%80%EC%84%B1%EC%9D%84-%EC%9C%A0%EC%A7%80%ED%95%98%EB%9D%BC)
    - [G33: 경계 조건을 캡슐화하라](#g33-%EA%B2%BD%EA%B3%84-%EC%A1%B0%EA%B1%B4%EC%9D%84-%EC%BA%A1%EC%8A%90%ED%99%94%ED%95%98%EB%9D%BC)
    - [G34: 함수는 추상화 수준을 한 단계만 내려가야 한다](#g34-%ED%95%A8%EC%88%98%EB%8A%94-%EC%B6%94%EC%83%81%ED%99%94-%EC%88%98%EC%A4%80%EC%9D%84-%ED%95%9C-%EB%8B%A8%EA%B3%84%EB%A7%8C-%EB%82%B4%EB%A0%A4%EA%B0%80%EC%95%BC-%ED%95%9C%EB%8B%A4)
    - [G35: 설정 정보는 최상위 단계에 둬라](#g35-%EC%84%A4%EC%A0%95-%EC%A0%95%EB%B3%B4%EB%8A%94-%EC%B5%9C%EC%83%81%EC%9C%84-%EB%8B%A8%EA%B3%84%EC%97%90-%EB%91%AC%EB%9D%BC)
    - [G36: 추이적 탐색을 피하라](#g36-%EC%B6%94%EC%9D%B4%EC%A0%81-%ED%83%90%EC%83%89%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC)
  - [자바](#%EC%9E%90%EB%B0%94)
    - [J1: 긴 import 목록을 피하고 와일드카드를 사용하라](#j1-%EA%B8%B4-import-%EB%AA%A9%EB%A1%9D%EC%9D%84-%ED%94%BC%ED%95%98%EA%B3%A0-%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
    - [J2: 상수는 상속하지 않는다](#j2-%EC%83%81%EC%88%98%EB%8A%94-%EC%83%81%EC%86%8D%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4)
    - [J3: 상수 대 enum](#j3-%EC%83%81%EC%88%98-%EB%8C%80-enum)
  - [이름](#%EC%9D%B4%EB%A6%84)
    - [N1: 서술적인 이름을 사용하라](#n1-%EC%84%9C%EC%88%A0%EC%A0%81%EC%9D%B8-%EC%9D%B4%EB%A6%84%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
    - [N2: 적절한 추상화 수준에서 이름을 선택하라](#n2-%EC%A0%81%EC%A0%88%ED%95%9C-%EC%B6%94%EC%83%81%ED%99%94-%EC%88%98%EC%A4%80%EC%97%90%EC%84%9C-%EC%9D%B4%EB%A6%84%EC%9D%84-%EC%84%A0%ED%83%9D%ED%95%98%EB%9D%BC)
    - [N3: 가능하다면 표준 명명법을 사용하라](#n3-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4%EB%A9%B4-%ED%91%9C%EC%A4%80-%EB%AA%85%EB%AA%85%EB%B2%95%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
    - [N4: 명확한 이름](#n4-%EB%AA%85%ED%99%95%ED%95%9C-%EC%9D%B4%EB%A6%84)
    - [N5: 긴 범위에는 긴 이름을 사용하라](#n5-%EA%B8%B4-%EB%B2%94%EC%9C%84%EC%97%90%EB%8A%94-%EA%B8%B4-%EC%9D%B4%EB%A6%84%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
    - [N6: 인코딩을 피하라](#n6-%EC%9D%B8%EC%BD%94%EB%94%A9%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC)
    - [N7: 이름으로 부수 효과를 설명하라](#n7-%EC%9D%B4%EB%A6%84%EC%9C%BC%EB%A1%9C-%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC%EB%A5%BC-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC)
  - [테스트](#%ED%85%8C%EC%8A%A4%ED%8A%B8)
    - [T1: 불충분한 테스트](#t1-%EB%B6%88%EC%B6%A9%EB%B6%84%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8)
    - [T2: 커버리지 도구를 사용하라!](#t2-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%EB%8F%84%EA%B5%AC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
    - [T3: 사소한 테스트를 건너뛰지 말라](#t3-%EC%82%AC%EC%86%8C%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EA%B1%B4%EB%84%88%EB%9B%B0%EC%A7%80-%EB%A7%90%EB%9D%BC)
    - [T4: 무시한 테스트는 모호함을 뜻한다](#t4-%EB%AC%B4%EC%8B%9C%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EB%AA%A8%ED%98%B8%ED%95%A8%EC%9D%84-%EB%9C%BB%ED%95%9C%EB%8B%A4)
    - [T5: 경계 조건을 테스트하라](#t5-%EA%B2%BD%EA%B3%84-%EC%A1%B0%EA%B1%B4%EC%9D%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%9D%BC)
    - [T6: 버그 주변은 철저히 테스트하라](#t6-%EB%B2%84%EA%B7%B8-%EC%A3%BC%EB%B3%80%EC%9D%80-%EC%B2%A0%EC%A0%80%ED%9E%88-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%9D%BC)
    - [T7: 실패 패턴을 살펴라](#t7-%EC%8B%A4%ED%8C%A8-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%82%B4%ED%8E%B4%EB%9D%BC)
    - [T8: 테스트 커버리지 패턴을 살펴라](#t8-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%82%B4%ED%8E%B4%EB%9D%BC)
    - [T9: 테스트는 빨라야 한다](#t9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EB%B9%A8%EB%9D%BC%EC%95%BC-%ED%95%9C%EB%8B%A4)
  - [결론](#%EA%B2%B0%EB%A1%A0)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 17장. 냄새와 휴리스틱

## 주석

### C1: 부적절한 정보

다른 시스템에 저장할 정보

### C2: 쓸모없는 주석

### C3: 중복된 주석

코드만으로 충분한데 구구절절 설명

### C4: 성의 없는 주석

작성할 가치가 있는 주석은 잘 작성할 가치도 있다.

### C5: 주석 처리된 코드

얼마나 오래된 코드인지, 중요한 코드인지 아닌지, 알 길이 없다.

즉각 지워버려라!

## 환경

### E1: 여러 단계로 빌드해야 한다

한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.

### E2: 여러 단계로 테스트해야 한다

모든 테스트를 한 번에 실행하는 능력은 아주 근본적이고 아주 중요하다.

## 함수

### F1: 너무 많은 인수

### F2: 출력 인수

직관을 정면으로 위배한다.

### F3: 플래그 인수

### F4: 죽은 함수

## 일반

### G1: 한 소스 파일에 여러 언어를 사용한다

현실적으로는 여러 언어가 불가피하다. 줄이도록 애써라.

### G2: 당연한 동작을 구현하지 않는다

최소 놀람의 원칙(The Principle of Least Surprise)

당연하게 여길 만한 동작과 기능을 제공해야 한다.

이를 어기는 저자는 신뢰할 수 없으므로 독자가 코드를 일일이 살펴야 한다.

### G3: 경계를 올바로 처리하지 않는다

### G4: 안전 절차 무시

- 컴파일러 대신 직접 제어(serialVersionUID 필드 등)
- 컴파일러 경고를 꺼버림
- 실패하는 테스트 케이스

### G5: 중복

중복은 추상화할 기회다.

유형

- 똑같은 코드 => 함수 추출
- 똑같은 조건(일련의 switch/case나 if/else 문)을 거듭 확인 => 다형성
- 알고리즘이 유사하나 코드가 서로 다른 중복 => TEMPLATE METHOD 패턴, STRATEGY 패턴

### G6: 추상화 수준이 올바르지 못하다

함수, 클래스, 소스 파일, 컴포넌트, 모듈 등 모든 수준에서 개념을 다양한 차원으로 분리해라.

### G7: 기초 클래스가 파생 클래스에 의존한다

예외: 파생 클래스 개수가 확실히 고정된 특수한 경우 (유한 상태 기계 등)

기초 클래스와 파생 클래스를 다른 JAR 파일로 배포할 때의 장점

- 독립적인 개별 컴포넌트 단위로 시스템을 배치할 수 있다.
- 변경이 시스템에 미치는 영향이 적어지므로 시스템을 유지 보수하기 쉬워진다.

### G8: 과도한 정보

잘 정의된 모듈은,

- 인터페이스가 아주 작다.
- 많은 동작이 가능하다.
- 결합도가 낮다.

자료를 숨겨라. 정보를 제한해 결합도를 낮춰라.

### G9: 죽은 코드

설계가 변해도 제대로 수정되지 않는다.

### G10: 수직 분리

비공개 함수는 처음으로 호출한 직후에 정의한다.

### G11: 일관성 부족

최소 놀람의 원칙

### G12: 잡동사니

비어 있는 기본 생성자, 아무도 사용하지 않는 변수•함수, 의미 없는 주석 등

### G13: 인위적 결합

뚜렷한 목적 없이 변수, 상수, 함수를 당장 편한 (잘못된) 위치에 넣어버린 결과.

일반적인 enum, 범용 static 함수는 특정 클래스에 속할 이유가 없다.

### G14: 기능 욕심

예외: 욕심부리지 않으면 객체 지향 설계의 다른 여러 원칙을 위반하게 되는 상황

### G15: 선택자 인수

- 목적을 기억하기 어렵다.
- 여러 함수를 하나로 조합한다.

### G16: 모호한 의도

행을 바꾸지 않고 표현한 수식, 헝가리식 표기법, 매직 번호 등

### G17: 잘못 지운 책임

최소 놀람의 원칙

개발자에게 편한 곳이 아닌, 독자에게 직관적인 위치에 기능을 배치하라.

예외: 반드시 성능을 높여야 하는 경우 이런 사실을 반영한 이름 사용

### G18: 부적절한 static 함수

특정 객체와 관련이 없으면서 모든 정보를 인수에서 가져오는 것처럼 보이는 함수

- 인수 중 하나의 타입의 인스턴스 함수로 정의하면 재정의할 가능성을 열어둘 수 있다.

### G19: 서술적 변수

계산을 여러 단계로 나누고 중간값으로 서술적인 변수 이름을 사용

### G20: 이름과 기능이 일치하는 함수

이름만으로 분명하지 않기에 구현을 살피거나 문서를 뒤적여야 한다면,

- 더 좋은 이름으로 바꾸거나
- 더 좋은 이름을 붙이기 쉽도록 기능을 정리해야 한다.

### G21: 알고리즘을 이해하라

함수가 돌아가는 방식을 확실히 이해했다고 할 수 있으려면,

- 테스트 케이스를 모두 통과한다는 사실만으로는 부족하다.
- 작성자가 알고리즘이 올바르다는 사실을 알아야 한다.

기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성하는 방법이 최고다.

### G22: 논리적 의존성은 물리적으로 드러내라

상대 모듈에 대해 뭔가를 가정하면(즉, 논리적으로 의존하면) 안 된다.

- 의존하는 모든 정보를 명시적으로 요청하는 편이 좋다.
- 그 가정을 상대 모듈 상의 기능으로 표현하고, 명시적으로 그 기능을 이용하라.

### G23: if/else 혹은 switch/case 문보다 다형성을 사용하라

유형보다 함수가 더 쉽게 변하는 경우는 극히 드물다. 따라서 모든 switch 문이 의심 대상이다.

'switch 문 하나' 규칙

- 선택 유형 하나에 switch 문을 한 번만 사용하여 다형성 객체 생성
- 다른 곳에서는 이 다형성 객체 이용

### G24: 표준 표기법을 따르라

팀 표준

- 업계 표준에 기반을 둔 구현 표준 정의(합의)
- 표준을 설명하는 문서는 코드 자체로 충분해야 한다.

팀원 모두가 따라야 한다.

- 모두가 동의한 방식을 따른다는 사실이 중요하다.
- 이 사실을 이해할 정도로 팀원들이 성숙해야 한다.

### G25: 매직 숫자는 명명된 상수로 교체하라

어떤 상수는 이해하기 쉬우므로, 코드 자체가 자명하다면 상수 뒤로 숨길 필요가 없다.

의미가 분명하지 않은 모든 토큰이 적용 대상이다.

### G26: 정확하라

코드에서 뭔가를 결정할 때는 결정을 내리는 이유와 예외를 처리할 방법을 분명히 알아야 한다.

### G27: 관례보다 구조를 사용하라

설계 결정을 강제할 때는 규칙보다 관례를 사용한다. 하지만 구조 자체로 강제하면 더 좋다.

### G28: 조건을 캡슐화하라

### G29: 부정 조건은 피하라

### G30: 함수는 한 가지만 해야 한다

### G31: 숨겨진 시간적 결합

함수 인수를 적절히 배치(연결 소자)해 함수가 호출되는 순서를 명백히 드러내라.

(15장에서 다룬 `findCommonPrefixAndSuffix` 함수에서는 더 급진적인 방식을 사용하고 있다.)

### G32: 일관성을 유지하라

구조에 일관성이 없어 보인다면 남들이 맘대로 바꿔도 괜찮다고 생각한다.

### G33: 경계 조건을 캡슐화하라

경계 조건은 한 곳에서 별도로 처리한다. 코드 여기저기에서 처리하지 않는다.

### G34: 함수는 추상화 수준을 한 단계만 내려가야 한다

가장 이해하고 따르기 어려운 휴리스틱.

추상화 수준을 분리하면 앞서 드러나지 않았던 새로운 추상화 수준이 드러나는 경우가 빈번하다.

### G35: 설정 정보는 최상위 단계에 둬라

고차원 함수에서 저차원 함수를 호출할 때 인수로 넘기는 방식이어야 설정값을 변경하기 쉽다.

### G36: 추이적 탐색을 피하라

디미터의 법칙, 부끄럼 타는 코드 작성

너무 많은 모듈이 아키텍처를 너무 많이 알면 아키텍처가 굳어진다.

## 자바

### J1: 긴 import 목록을 피하고 와일드카드를 사용하라

한 패키지에서 클래스를 둘 이상 사용할 경우 와일드카드로 교체.

모듈 간에 결합성이 낮아진다.

간혹 이름 충돌이나 모호성을 초래하는 경우

- 명시적인 import 문
- 코드에서 클래스를 사용할 때 전체 경로를 명시

### J2: 상수는 상속하지 않는다

언어의 범위 규칙을 속이는 행위

### J3: 상수 대 enum

## 이름

### N1: 서술적인 이름을 사용하라

소프트웨어가 진화하면 의미도 변하므로 선택한 이름이 적합한지 자주 되돌아본다.

소프트웨어 가독성의 90%는 이름이 결정한다.

### N2: 적절한 추상화 수준에서 이름을 선택하라

구현을 드러내는 이름은 피하라.

### N3: 가능하다면 표준 명명법을 사용하라

패턴, 관례, (도메인 주도 개발에서) 유비쿼터스 언어

### N4: 명확한 이름

길다는 단점을 서술성이 충분히 메꾼다.

### N5: 긴 범위에는 긴 이름을 사용하라

### N6: 인코딩을 피하라

접두어, 헝가리안 표기법 등

### N7: 이름으로 부수 효과를 설명하라

하는 일을 모두 기술하는 이름 사용

## 테스트

### T1: 불충분한 테스트

잠재적으로 깨질 만한 부분을 모두 테스트하라.

### T2: 커버리지 도구를 사용하라!

### T3: 사소한 테스트를 건너뛰지 말라

사소한 테스트는 짜기 쉽다.

문서적 가치가 구현에 드는 비용을 넘어선다.

### T4: 무시한 테스트는 모호함을 뜻한다

불분명한 요구사항을 표현하는 방법

- 테스트 케이스를 주석으로 처리 (컴파일 불가능한 경우)
- 테스트 케이스 `@Ignore` 표시

### T5: 경계 조건을 테스트하라

### T6: 버그 주변은 철저히 테스트하라

버그는 서로 모이는 경향이 있다.

### T7: 실패 패턴을 살펴라

합리적인 순서로 정렬된 꼼꼼한 테스트 케이스는 실패 패턴을 드러낸다.

### T8: 테스트 커버리지 패턴을 살펴라

- 통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴라.
- 실패하는 테스트 케이스의 실패 원인이 드러난다.

### T9: 테스트는 빨라야 한다

## 결론

이 목록은 

- 완전하지 않다.
- 가치 체계를 피력할 뿐이다.

전문가 정신과 장인 정신은 가치에서 나온다. 그 가치에 기반을 둔 규율과 절제가 필요하다.
