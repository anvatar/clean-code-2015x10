<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [3장. 함수](#3%EC%9E%A5-%ED%95%A8%EC%88%98)
  - [작게 만들어라!](#%EC%9E%91%EA%B2%8C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC)
  - [한 가지만 해라!](#%ED%95%9C-%EA%B0%80%EC%A7%80%EB%A7%8C-%ED%95%B4%EB%9D%BC)
  - [함수 당 추상화 수준은 하나로!](#%ED%95%A8%EC%88%98-%EB%8B%B9-%EC%B6%94%EC%83%81%ED%99%94-%EC%88%98%EC%A4%80%EC%9D%80-%ED%95%98%EB%82%98%EB%A1%9C)
  - [Switch 문](#switch-%EB%AC%B8)
  - [서술적인 이름을 사용하라!](#%EC%84%9C%EC%88%A0%EC%A0%81%EC%9D%B8-%EC%9D%B4%EB%A6%84%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
  - [함수 인수](#%ED%95%A8%EC%88%98-%EC%9D%B8%EC%88%98)
  - [부수 효과를 일으키지 마라!](#%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC%EB%A5%BC-%EC%9D%BC%EC%9C%BC%ED%82%A4%EC%A7%80-%EB%A7%88%EB%9D%BC)
  - [명령과 조회를 분리하라!](#%EB%AA%85%EB%A0%B9%EA%B3%BC-%EC%A1%B0%ED%9A%8C%EB%A5%BC-%EB%B6%84%EB%A6%AC%ED%95%98%EB%9D%BC)
  - [오류 코드보다 예외를 사용하라!](#%EC%98%A4%EB%A5%98-%EC%BD%94%EB%93%9C%EB%B3%B4%EB%8B%A4-%EC%98%88%EC%99%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
  - [반복하지 마라!](#%EB%B0%98%EB%B3%B5%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BC)
  - [함수를 어떻게 짜죠?](#%ED%95%A8%EC%88%98%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A7%9C%EC%A3%A0)
  - [결론](#%EA%B2%B0%EB%A1%A0)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 3장. 함수

- 의도를 분명히 표현하는 함수를 어떻게 구현할 수 있을까?
- 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?

## 작게 만들어라!

근거를 대기는 곤란하지만, 수십 년의 경험과 오랜 시헝착오를 바탕으로 확신한다.

블록과 들여쓰기

- if/else/while 문 등에 들어가는 블록은 한 줄이어야 한다.
- 중첩 구조가 생길만큼 함수가 커져서는 안 된다.
- 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

## 한 가지만 해라!

"함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다."

- 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 하는 것이다.
- 단순히 다른 표현이 아니라, 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.
- 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

## 함수 당 추상화 수준은 하나로!

한 함수 내에 추상화 수준이 섞여 있으면 코드를 읽는 사람이 헷갈린다.

- 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어렵다.
- 깨진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.

위에서 아래로 코드 읽기: **내려가기** 규칙

- 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
- 일련의 TO 문단을 읽듯이 프로그램이 읽혀야 한다.
- 각 함수는 다음 함수를 소개한다. 각 함수는 일정한 추상화 수준을 유지한다.

## Switch 문

목록 3-4(직원 유형에 따라 다른 값을 계산해 반환하는 함수)의 문제

- 함수가 길다. 새 유형을 추가하면 더 길어진다.
- 한 가지 작업만 수행하지 않는다.
- 코드를 변경할 이유가 여럿이다. (Single Responsibility Principle 위반)
- 새 유형을 추가할 때마다 코드를 변경해야 한다. (Open Closed Principle 위반)
- *똑같은 구조의 switch 문이 여러 곳에 존재할 수 있다.*

switch 문은 적절한 파생 클래스의 인스턴스를 생성하는 추상 팩토리 내에서 단 한 번만 사용하고, 유형에 따라 달라지는 동작은 다형성으로 해결한다.

## 서술적인 이름을 사용하라!

한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 "짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드"라는 원칙의 절반은 달성한 것이다.

길고 서술적인 이름

- 짧고 어려운 이름이나 길고 서술적인 주석보다 좋다.
- IDE를 사용해 이런저런 이름을 시도한 후 최대한 서술적인 이름을 골라라.
- 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.

모듈 내에서 함수 이름은 일관성 있게 짓는 것이 좋다.

## 함수 인수

- 이상적인 인수 개수는 0개(무항)다.
- 차선은 1개(단항)고, 다음은 2개(이항)다.
- 3개(삼항)은 가능한 피하는 편이 좋다. 4개(다항)은 특별한 이유가 필요하다.

인수는 어렵다.

- `includeSetupPageInto(newPageContent)` => `includeSetupPage()`
    - 함수 이름과 인수 사이에 추상화 수준이 다르다.
    - 현 시점에서 별로 중요하지 않은 세부사항인 StringBuffer를 알아야 한다.
- 인수가 많으면 더 많은 인수의 조합을 테스트 해야 한다.
- 출력 인수는 입력 인수보다 더 어렵다.
- 플래그 인수는 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이므로 추하다.

많이 쓰는 단항 형식: 질문, 변환(, 이벤트)

- 분명히 구분하여 함수 이름을 짓고, 일관적인 방식으로 사용한다.
- 입력 인수를 그대로 돌려주는 함수라 할지라도 변환 함수 형식을 따르는 편이 좋다.

이항 함수

- `Point p = new Point(0, 0)`: 한 값을 표현하는 두 요소이며 자연적인 순서가 존재하므로 적절하다.
- `writeField(outputStream, name)`는 잠시 주춤하며 첫 인수를 무시(무시에는 오류의 가능성도 존재함)해야 하므로 나쁘다.
    - writeField 메서드를 outputStream 클래스의 구성원으로 만들어 `outputStream.writeField(name)`으로 호출하거나,
    - outputStream을 현재(또는 새로운) 클래스의 구성원으로 만들어 인수로 넘기지 않게 한다.

삼항 함수

- 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다.
- `assertEquals(message, expected, actual)`는 첫 번째 인수가 expected가 아니라서 헷갈리므로 나쁘다.
- `assertEquals(1.0, amount, .001)`는 어쩔 수 없이 세 번째 인수가 필요한 경우라서 괜찮다.

인수가 많아진다면 일부를 별도 클래스로 추출(인수 객체)하여 인수 개수도 줄이고, 추가적인 개념을 표현하라.

가변 인수는 List 형 인수 하나인 것처럼 생각하고 원칙을 적용한다.

동사와 키워드

- 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
    - `writeField(name)`는 이해하기 쉬우면서 name이 필드라는 사실도 드러내준다.
- 함수 이름에 키워드(인수 이름)를 추가하는 방법도 있다.
    - `assertExpectedEqualsActual(expect, actual)`: 인수 순서를 기억할 필요가 없어진다.

## 부수 효과를 일으키지 마라!

`checkPassword()` 사례

- 이름에서 세션을 초기화한다는 사실이 드러나지 않음
    - `checkPasswordAndInitializeSession`이 낫다.
- 세션을 초기화해도 괜찮은 상황에서만 호출 가능 (시간적인 결합, 순서 종속성)
- 함수가 여러 작업을 함

출력 인수를 피하라.

- 함수 선언부를 찾아보고 나서야 출력 인수인지 아닌지를 알 수 있다.
- 객체 지향 언어에서는 현재 객체(this) 상태를 변경하는 방식을 택하라.

## 명령과 조회를 분리하라!

`public boolean set(String attribute, String value);` 사례

- if 문의 조건으로 사용했을 때 확인하는 코드인지 설정하는 코드인지 알 수 없음.
- 조회(`attributeExists()`)와 명령(`setAttribute()`)으로 분리하라.

## 오류 코드보다 예외를 사용하라!

오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.

try 블록과 catch 블록

- 정상 동작과 오류 처리 동작을 뒤섞여 있어 코드 구조에 혼란을 일으킨다.
- 각각 별도 함수로 뽑아내는 편이 좋다.
- 오류 처리도 한 가지 작업이므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다.

오류 코드 목록을 표현한 클래스(Error enum 등)는 많은 곳에서 import 하여 사용하게 되는 '의존성 자석'이다.
 
- 이 목록이 변하면 클라이언트 코드를 전부 재컴파일/재배포해야 하므로 프로그래머는 새 오류 코드를 추가하지 못하고 기존 오류 코드를 재사용한다.
- 예외는 enum과 달리 재컴파일/재배포 없이도 새 예외 클래스를 추가할 수 있다.

## 반복하지 마라!

코드 길이가 늘어나고, 유지보수가 어려워지고, 버그가 발생할 가능성이 높아진다.

어쩌면 중복은 소프트웨어에서 모든 악의 근원이다.

## 함수를 어떻게 짜죠?

처음에는 서투르게 짜도 괜찮다. 단, 서투른 코드를 빠짐없이 테스트하는 단위 테스트 케이스도 같이 만든다.

리팩터링을 통해 최종적으로 규칙을 따르는 함수가 얻는다. 단, 단위 테스트를 통과하는 상태를 항상 유지한다.

## 결론

모든 시스템은 도메인 특화 언어로 만들어진다.

- 함수는 그 언어에서 동사며, 클래스는 명사다.
- 프로그래밍의 기술은 언제나 언어 설계의 기술이다.
- 프로그래밍의 대가는 시스템을 (구현할) 프로그램이 아니라 (풀어갈) 이야기로 여긴다.
