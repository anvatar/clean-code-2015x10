<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [10장. 클래스](#10%EC%9E%A5-%ED%81%B4%EB%9E%98%EC%8A%A4)
  - [클래스 체계](#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B2%B4%EA%B3%84)
  - [클래스는 작아야 한다!](#%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%9E%91%EC%95%84%EC%95%BC-%ED%95%9C%EB%8B%A4)
    - [단일 책임 원칙](#%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99)
    - [응집도(cohesion)](#%EC%9D%91%EC%A7%91%EB%8F%84cohesion)
  - [변경하기 쉬운 클래스](#%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0-%EC%89%AC%EC%9A%B4-%ED%81%B4%EB%9E%98%EC%8A%A4)
    - [변경으로부터 격리](#%EB%B3%80%EA%B2%BD%EC%9C%BC%EB%A1%9C%EB%B6%80%ED%84%B0-%EA%B2%A9%EB%A6%AC)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 10장. 클래스

## 클래스 체계

클래스 구성 요소 정의 순서(표준 자바 관례):

- 변수 목록: 정적 공개 상수 » 정적 비공개 변수 » 비공개 인스턴스 변수
- 공개 함수
    - 비공개 함수는 자신을 호출하는 공개 함수 직후
    - 추상화 단계가 순차적으로 내려감 (신문 기사처럼)

캡슐화

- 변수와 유틸리티 함수는 가능하면 공개하지 않는다. (법칙은 아님)
- 불가피할 경우 테스트 코드로부터의 접근을 허용하기 위해 protected나 package private으로 선언하기도 한다.

## 클래스는 작아야 한다!

함수도 작게, 클래스도 작게.

얼마나 작아야 하는가?

- 함수는 3줄 내외
- 클래스는 1개의 책임
    - 메서드가 5개라도 책임이 2개 이상이면 문제 있는 클래스.

너무 큰 클래스 냄새

- 간결하고 명확한 이름을 붙일 수 없다.
- 이름에 Processor, Manager, Super 등의 모호한 단어를 사용한다.
- If, and, or, but 없이 25단어 내외로 클래스를 설명하는 것이 불가능하다.

### 단일 책임 원칙

SRP(single responsibility principle)

- 클래스나 모듈을 변경할 이유가 단 하나여야 한다.
    - 변경할 이유 = 책임
- 잘 지켜지지 않는 원인
    1. 프로그램이 돌아가면 일이 끝났다고 여기는 태도
        - '만능' 클래스를 단일 책임 클래스 여럿으로 분리하지 않고 다음 문제로 넘어가버린다.
    1. 자잘한 단일 책임 클래스가 많아지면 큰 그림을 이해하기 어려워진다는 우려
        - "큰 그림을 이해하려면 이 클래스 저 클래스를 수없이 넘나들어야해!"

체계적으로 정리를 하든 안 하든 시스템을 이해하는데 필요한 지식의 양은 비슷하다.

기능과 이름이 명확한 컴포넌트로 분리해 두어야

- 필요할 때 무엇이 어디에 있는지 쉽게 찾는다.
- (변경을 가할 때) 직접 영향이 미치는 컴포넌트만 이해하면 된다.

작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.

- 작은 클래스는 각자 맡은 책임 하나며,
- 변경할 이유가 하나며,
- 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.

### 응집도(cohesion)

높은 응집도

- 각 메서드가 대부분의 인스턴스 변수를 사용한다.
- 메서드와 인스턴스 변수가 서로 의존하며 논리적인 단위로 묶인다.

응집도를 유지하기 위해 클래스 쪼개기

- 큰 함수를 작은 함수 여럿으로 나누기
    - 추출한 메서드에서 사용하는 변수를 인스턴스 변수로 승격하면 매개변수 목록이 짧아짐.
- 함수를 작게, 매개변수 목록을 짧게 만들기
    - 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아질 수 있음.
- 클래스가 응집력을 잃는다?
    - 응집된 단위로 새로운 클래스들을 추출해야 한다는 신호.

## 변경하기 쉬운 클래스

예: Sql 클래스

- SRP 위반
    - 1) 새로운 SQL 문을 지원하거나, 2) 기존 SQL 문을 수정하려면, Sql 클래스를 수정해야 함.
    - 특정 SQL 문을 처리할 때만 필요한 비공개 메서드의 존재
- 설계 개선의 여지 있음.
    - 단, 시스템에 변경이 필요하지 않다면 굳이 손대지 않는다.

예: Sql 클래스 계층

- 설계 변경
    - 각 공개 인터페이스(각 SQL 문)를 Sql 클래스의 파생 클래스로 만듦.
    - 특정 SQL 문을 처리할 때만 필요한 비공개 메서드는 해당 파생 클래스로 이동.
    - 모든 파생 클래스에서 사용하는 비공개 메서드는 별도 유틸리티 클래스로 추출.
- 효과
    - 각 클래스를 매우 쉽게 이해할 수 있음.
    - 한 함수를 수정했을 때 다른 함수가 망가질 위험이 사라짐.
    - 모든 논리를 구석구석 증명하기 쉬워짐.
    - SRP 지원
        - 새로운 SQL 문을 지원하기 위해 기존 클래스를 변경할 필요가 없음.
    - OCP(open-closed principle) 지원
        - (기존 클래스를 건드리지 않고도) 파생 클래스를 생성하는 방식으로 새 기능에 개방적
        - 한 클래스를 변경하더라도 다른 클래스는 (영향을 받지 않으므로) 수정에 폐쇄적

새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다.

- 시스템은 지속적으로 변하고, 모든 변경은 위험을 수반한다.
- 깨끗한 시스템은 클래스를 체계적으로 정리해 위험을 낮춘다.

### 변경으로부터 격리

상세한 구현에 의존하는 클라이언트 코드는 구현이 바뀌면 위험에 빠진다.

인터페이스나 추상 클래스를 사용하여 결합도를 낮추자.

- 유연성과 재사용성이 높아진다.
- 시스템의 각 요소가 다른 요소로부터 잘 격리된다.
    - 다른 요소의 변경으로부터 잘 격리된다.
    - 각 요소를 이해하기 쉽다.
- 가짜 객체를 활용하여 테스트 하기도 쉽다.
- DIP(dependency inversion principle) 지원
    - 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙