# 1장. 깨끗한 코드

## 코드가 존재하리라

프로그래밍 언어의 추상화 수준은 점차 높아지고 DSL도 점차 많아진다.

하지만 코드가 사라지지는 않을 것이다.

- 창의력과 직관을 보유한 우리 인간에게도 어려운 일을 기계가 할 수는 없을 것이다.
- 코드는 요구사항을 표현하는 궁극의 언어이다.

## 나쁜 코드

좋은 코드는 중요하다.

- 잘 나가던 회사가 나쁜 코드 때문에 망하기도 한다.

## 나쁜 코드로 치르는 대가

빨리 가는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.

- 지금까지 여러가지 이유로 나쁜 코드를 작성해 왔다. 나중에 정리하겠다는 다짐은 소용 없다. 나중은 결코 오지 않는다.
- 나쁜 코드가 쌓일수록 팀의 생산성은 떨어진다. 인력을 추가로 투입해도 새 인력은 시스템 설계에 대한 조예가 깊지 않다. 생산성은 결국 거의 0이 된다.
- 재설계는 헛된 꿈이다.
- 시간을 들여 깨끗한 코드를 만드는 노력이 비용을 절감하는 방법일 뿐만 아니라 전문가로서 살아남는 길이다.

프로젝트 실패는 우리에게도 커다란 책임이 있다. 특히 나쁜 코드가 초래하는 실패에는 더더욱 책임이 크다.

- 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.

깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 안다는 뜻은 아니다. *코드 감각*이 있어야 한다.

- 좋은 코드와 나쁜 코드를 구분하고,
- 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악한다.

### 비야네 스트롭스트룹

> 나는 우아하고 효율적인 코드를 좋아한다. 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다. 오류는 명백한 전략에 의거해 철저히 처리한다. 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를 제대로 한다.

### 그래디 부치

> 개끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다.

### '큰' 데이브 토마스

읽기 쉬운 코드와 고치기 쉬운 코드는 다르다.

테스트 케이스가 없는 코드는 깨끗한 코드가 아니다.

### 마이클 페더스

코드를 주의 깊게 짜는 방법

### 론 제프리스

켄트 벡이 제안한 단순한 코드 규칙

- 모든 테스트를 통과한다.
- 중복이 없다.
    - 중복이 있다는 것은 코드가 아이디어를 제대로 표현하지 못한다는 증거다.
- 시스템 내 모든 설계 아이디어를 표현한다.
    - 의미 있는 이름
    - 기능을 명확히 기술하는 메서드, 기능을 실제로 수행하는 메서드
- 클래스, 메서드, 함수 등을 최대한 줄인다.

### 워드 커닝햄

> 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.

## 우리들 생각

오브젝트 멘토 진영의 생각

- 절대적으로 옳은 것은 아니다.

## 우리는 저자다

코드를 읽는 시간 대 코드를 자는 시간 비율이 10대 1을 훌쩍 넘는다. 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다.

## 보이스카우트 규칙

> 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.

## 프리퀄과 원칙

- SRP(The Single Responsibility Prilciple): 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다.
- OCP(The Open Closed Principle): 클래스는 확장에 열려 있어야 하며 변경에 닫혀 있어야 한다.
- LSP(The Liskov Substitution Principle): 상속받은 클래스는 기초 클래스를 대체할 수 있어야 한다.
- DIP(The Dependency Inversion Principle): 추상화에 의존해야 하며, 구체화에 의존하면 안 된다.
- ISP(The Interface Segregation Principle): 클라이언트에 밀접하게 작게 쪼개진 인터페이스를 유지한다.

## 결론

이 책은 뛰어난 프로그래머가 생각하는 방식과 그들이 사용하는 기술과 기교와 도구를 소개할 뿐이다.