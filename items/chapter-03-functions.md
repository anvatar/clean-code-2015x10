# 3장. 함수

FitNesse의 `static String testableHtml(PageData, boolean)` 함수 사례

- 추상화 수준도 너무 다양하고, 코드도 너무 길다.
- 메서드 몇 개를 추출하고, 이름 몇 개를 변경하고, 구조를 변경 => 함수 의도를 코드 9줄로 표현

문제 제기

- 의도를 분명히 표현하는 함수를 어떻게 구현할 수 있을까?
- 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?

## 작게 만들어라!

근거를 대기는 곤란하지만, 수십 년의 경험과 오랜 시헝착오를 바탕으로 확신한다.

9줄보다는 짧아야 한다. 3줄 정도는 적당하다.

블록과 들여쓰기

- if/else/while 문 등에 들어가는 블록은 한 줄이어야 한다.
- 중첩 구조가 생길만큼 함수가 커져서는 안 된다.
- 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

## 한 가지만 해라!

함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 하는 것이다.

- 단순히 다른 표현이 아니라, 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.
- 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

## 함수 당 추상화 수준은 하나로!

목록 3-1의 문제

- getHtml()은 추상화 수준이 아주 높다.
- `String pagePathName = PathParser.render(pagepath);`는 추상화 수준이 중간이다.
- `.append("\n")`은 추상화 수준이 아주 낮다.

한 함수 내에 추상화 수준이 섞여 있으면 코드를 읽는 사람이 헷갈린다.

- 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어렵다.
- 깨진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.

위에서 아래로 코드 읽기: **내려가기** 규칙

- 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
- 일련의 TO 문단을 읽듯이 프로그램이 읽혀야 한다.

목록 3-7에서 각 함수는 다음 함수를 소개한다. 각 함수는 일정한 추상화 수준을 유지한다.

## Switch 문

switch 문은 작게 만들기 어렵다. 하지만 다형성을 이용해 각 switch 문을 파생 클래스에 숨기고 절대로 반복하지 않는 방법은 있다.

목록 3-4(직원 유형에 따라 다른 값을 계산해 반환하는 함수)의 문제

- 함수가 길다. 새 유형을 추가하면 더 길어진다.
- 한 가지 작업만 수행하지 않는다.
- SRP(Single Responsibility Principle)를 위반한다.
    - 코드를 변경할 이유가 여럿이다.
- OCP(Open Closed Principle)를 위반한다.
    - 새 유형을 추가할 때마다 코드를 변경해야 한다.
- 똑같은 구조의 switch 문이 여러 곳에 존재할 수 있다.

switch 문은 적절한 파생 클래스의 인스턴스를 생성하는 추상 팩토리 내에서 단 한 번만 사용하고, 유형에 따라 달라지는 동작은 다형성으로 해결한다.

## 서술적인 이름을 사용하라!

"짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드"

- 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 원칙의 절반은 달성한 것이다.

길고 서술적인 이름이 짧고 어려운 이름이나 길고 서술적인 주석보다 좋다.

시간을 들여 IDE를 사용해 이런저런 이름을 시도한 후 최대한 서술적인 이름을 골라라.

서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.

모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용하여 일관성 있게 짓는다. 문체가 비슷하면 이야기를 순차적으로 풀어가기도 쉬워진다.

## 함수 인수

- 이상적인 인수 개수는 0개(무항)다.
- 차선은 1개(단항)고,
- 다음은 2개(이항)다.
- 3개(삼항)은 가능한 피하는 편이 좋다.
- 4개(다항)은 특별한 이유가 필요하다.

인수는 개념을 이해하기 어렵게 만든다.

- 출력 인수는 입력 인수보다 이해하기 더 어렵다.

`includeSetupPageInto(newPageContent)` => `includeSetupPage()`

- 함수 이름과 인수 사이에 추상화 수준이 다르다.
- 현 시점에서 별로 중요하지 않은 세부사항인 StringBuffer를 알아야 한다.

인수가 많으면 더 많은 인수의 조합을 테스트 해야 한다.

많이 쓰는 단항 형식

- 질문, 변환
    - 가장 흔한 경우들.
    - 분명히 구분하여 함수 이름을 짓고, 일관적인 방식으로 사용한다.
    - 입력 인수를 그대로 돌려주는 함수라 할지라도 변환 함수 형식을 따르는 편이 좋다.
- 이벤트
    - 간혹 유용하다.
    - 이벤트라는 사실이 코드에 명확히 드러나야 한다.

플래그 인수

- 추하다.
- 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈

이항 함수

- `writeField(outputStream, name)` (나쁨)
    - 잠시 주춤하며 첫 인수를 무시해야 한다.
    - 무시한 코드에 오류가 있을 수 있다.
    - writeField 메서드를 outputStream 클래스의 구성원으로 만들어 `outputStream.writeField(name)`으로 호출하거나, outputStream을 현재(또는 새로운) 클래스의 구성원으로 만들어 인수로 넘기지 않아야 한다.
- `Point p = new Point(0, 0)` (적절)
    - 한 값을 표현하는 두 요소
    - 자연적인 순서가 존재

삼항 함수

- 순서 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다.
- `assertEquals(message, expected, actual)` (나쁨)
    - 첫 번째 인수가 expected가 아니라서 헷갈림
- `assertEquals(1.0, amount, .001)` (적절)
    - 어쩔 수 없이 세 번째 인수가 필요한 경우

인수 객체

- 인수가 많아진다면 일부 인수를 독자적인 클래스로 추출하는 것을 고려하라.
- 클래스에 이름을 붙여야 하므로 개념을 표현하게 된다.

인수 목록

- 가변 인수 전부를 동등하게 취급하면 List 형 인수 하나로 취급할 수 있다.
- 그 후에 다른 함수와 같은 원리를 적용하면 된다.

동사와 키워드

- 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
    - `writeField(name)`
    - 이해하기 쉬움
    - name이 필드라는 사실을 드러냄
- 함수 이름에 키워드(인수 이름)를 추가하기도 한다.
    - `assertEquals(expected, actual)` => `assertExpectedEqualsActual(expecte, actual)`
    - 인수 순서를 기억할 필요가 없어짐.

## 부수 효과를 일으키지 마라!

부수효과는 시간적인 결합이나 순서 종속성을 초래한다.

`checkPassword()` => `checkPasswordAndInitializeSession ` 사례

- 이름만 봐서는 세션을 초기화한다는 사실이 드러나지 않음
- 특정 상황(세션을 초기화해도 괜찮은)에서만 호출 가능
- 이름 변경 후에도 여전히 함수가 여러가지를 하는 문제는 남아 있음

출력 인수

- 일반적으로 출력 인수는 피해야 한다.
- 함수 선언부를 찾아보고 나서야 출력 인수인지 아닌지를 알 수 있다.
- 객체 지향 언어에서는 현재 객체(this) 상태를 변경하는 방식을 택하라.

## 명령과 조회를 분리하라!

`public boolean set(String attribute, String value);`

- 확인하는 코드인지 설정하는 코드인지 알 수 없음.
- 조회(`attributeExists()`)와 명령(`setAttribute()`)을 분리하라.

## 오류 코드보다 예외를 사용하라!

오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.

try/catch 블록 뽑아내기

- try/catch 블록은 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다.
- try/catch 블록을 각각 별도 함수로 뽑아내는 편이 좋다.

오류 처리도 한 가지 작업이다.

- 오류를 처리하는 함수는 오류만 처리해야 마땅하다.

`enum Error`와 같은 클래스는 의존성 자석이다. 많은 곳에서 import 하여 사용한다.

- Error 클래스가 변한다면 이를 사용하는 클래스 전부를 다시 컴파일하고 배포해야 한다.
- 재컴파일/재배포가 번거로우므로 프로그래머는 새 오류 코드를 추가하지 못하고 기존 오류 코드를 재사용한다.
- 예외는 enum과 달리 재컴파일/재배포 없이도 새 예외 클래스를 추가할 수 있다.

## 반복하지 마라!

코드 길이가 늘어나고, 유지보수가 어려워지고, 버그가 발생할 가능성이 높아진다.

어쩌면 중복은 소프트웨어에서 모든 악의 근원이다.

## 구조적 프로그래밍

함수를 작게 마든다면 간혹 return, break, continue를 여러 차례 사용해도 괜찮다.

오히려 의도를 표현하기 쉬워진다.

## 함수를 어떻게 짜죠?

- 처음에는 서투르게 짠다.
- 하지만 빠짐없이 테스트하는 단위 테스트 케이스도 만든다.
- 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거하는 등 리팩토링을 수행한다. 이 와중에도 코드는 항상 단위 테스트를 통과한다.
- 최종적으로 규칙을 따르는 함수가 얻어진다.

## 결론

모든 시스템은 도메인 특화 언어로 만들어진다.

- 함수는 그 언어에서 동사며, 클래스는 명사다.
- 프로그래밍의 기술은 언제나 언어 설계의 기술이다.
- 프로그래밍의 대가는 시스템을 (구현할) 프로그램이 아니라 (풀어갈) 이야기로 여긴다.